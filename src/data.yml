machines:
  - name: Apple Macbook Air M2
    specs: |
      CPU: Apple M2
      RAM: LPDDR5 16GB
      Compiler: Homebrew Clang 17.0.6
      Kernel: Darwin Kernel Version 22.2.0: Fri Nov 11 02:06:26 PST 2022; root:xnu-8792.61.2~4/RELEASE_ARM64_T8112
      ... more to come

questions:
  - title: Memory vs Compute
    topic: Memory
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      TODO
  - title: TLB Miss
    topic: Memory
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      References:

      - [Translation Lookaside Buffer](https://en.wikipedia.org/wiki/Translation_lookaside_buffer)
  - title: Zero Initialized Array
    topic: Memory
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      References:

      - [Minor Page Fault](https://en.wikipedia.org/wiki/Page_fault#Minor)
  - title: Cache vs Memory
    topic: Memory
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      References:

      - [Minor Page Fault](https://en.wikipedia.org/wiki/Page_fault#Minor)
  - title: Prefetch
    topic: Memory
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      References:

      - [Minor Page Fault](https://en.wikipedia.org/wiki/Page_fault#Minor)
  - title: False Sharing
    topic: Memory
    code1: |
      struct Foo {
        int x;
        int y;
        int z;
      };
      std::vector<Foo> arr(100'000);

      # Run in 2 threads
      for (int i = thread_idx; i < arr.size(); i += 2) {
        arr[i].x = i;
        arr[i].y = arr.size() - i;
        arr[i].z = arr.size() + i;
      }
    code2: |
      struct alignas(64) Foo {
        int x;
        int y;
        int z;
      };
      std::vector<Foo> arr(100'000);

      # Run in 2 threads
      for (int i = thread_idx; i < arr.size(); i += 2) {
        arr[i].x = i;
        arr[i].y = arr.size() - i;
        arr[i].z = arr.size() + i;
      }
    answer: 2
    faster_factor: 1.2
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/memory/false_sharing.cpp
    explain: |
      False sharing happens when 2 cores read/write to different variables in the same cache line. In the example,
      Foo struct only has 3 integers, which is smaller than 1 cache line (64 bytes). Therefore, multiple instances of Foo will
      fit into a single cache line, causing the possibility for 2 cores to read/write at the same cache line.

      Adding alignment for Foo struct so that 1 cache line only has 1 Foo instance (at the cost of more memory) reduce this,
      and make the program run faster. Alternatively, you can divide the work between 2 threads differently (e.g. 0-size/2 to
      1 thread, and the rest to another thread).

      To measure effect of false sharing, you can use [perf c2c](https://man7.org/linux/man-pages/man1/perf-c2c.1.html).

      References:

        - [Wiki](https://en.wikipedia.org/wiki/False_sharing)
        - [docs.kernel.org](https://docs.kernel.org/kernel-hacking/false-sharing.html)
  - title: True Sharing
    topic: Memory
    code1: |
      constexpr int N = 128;
    code2: |
      constexpr int N = 128;
    answer: 2
    faster_factor: 3.4
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/memory/cache.cpp
    explain: |
      References:

        - [Wiki](https://en.wikipedia.org/wiki/Cache_placement_policies)
  - title: Cache Associativity
    topic: Memory
    code1: |
      constexpr int N = 64;

      for (auto j = 0u; j < 1024 / N; ++j) {
        for (auto i = 0u; i < N; ++i) {
          sum += arr1[i] + arr2[i];
        }
      }
    code2: |
      constexpr int N = 128;

      for (auto j = 0u; j < 1024 / N; ++j) {
        for (auto i = 0u; i < N; ++i) {
          sum += arr1[i] + arr2[i];
        }
      }
    answer: 2
    faster_factor: 3.4
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/memory/cache.cpp
    explain: |
      References:

        - [Wiki](https://en.wikipedia.org/wiki/Cache_placement_policies)
  - title: Cache Bank Conflict
    topic: Memory
    code1: |
      constexpr int N = 1;

      for (auto j = 0u; j < 1024 / N; ++j) {
        for (auto i = 0u; i < N; ++i) {
          sum += arr1[i] + arr2[i];
        }
      }
    code2: |
      constexpr int N = 2;

      for (auto j = 0u; j < 1024 / N; ++j) {
        for (auto i = 0u; i < N; ++i) {
          sum += arr1[i] + arr2[i];
        }
      }
    answer: 1
    faster_factor: 33.7
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/memory/cache.cpp
    explain: |
      TODO
  - title: Memory Bank Conflict
    topic: Memory
    code1: |
      constexpr int N = 1;
    code2: |
      constexpr int N = 2;
    answer: 1
    faster_factor: 33.7
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/memory/cache.cpp
    explain: |
      TODO
  - title: TLB Shoot Down
    topic: Memory
    code1: |
      for (int i = 0; i < 10'000'000; ++i) {
        sum += a[i % 1'000'000];
      }
    code2: |
      # Thread 1
      for (int i = 0; i < 1'000'000; ++i) {
        sum += a[i % 1'000'000];
      }

      # Thread 2
      while (++cnt) {
        if (cnt % 2 == 0)
          x = new int[10000];
        else
          delete [] x;
      }
    answer: 1
    faster_factor: 2
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/memory/tlb_shootdown.cpp
    explain: |
      TODO
  - title: Paused
    topic: Memory
    code1: |
      a
    code2: |
      b
    answer: 1
    faster_factor: 2
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/memory/tlb_shootdown.cpp
    explain: |
      TODO
  - title: Misalign
    topic: Memory
    code1: |
      a
    code2: |
      b
    answer: 1
    faster_factor: 2
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/memory/tlb_shootdown.cpp
    explain: |
      TODO
  - title: Recharge
    topic: Memory
    code1: |
      a
    code2: |
      b
    answer: 1
    faster_factor: 2
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/memory/tlb_shootdown.cpp
    explain: |
      TODO
  - title: Mooore Write
    topic: Memory
    code1: |
      a
    code2: |
      b
    answer: 1
    faster_factor: 2
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/memory/tlb_shootdown.cpp
    explain: |
      TODO

  - title: Sorted Array
    topic: CPU
    code1: |
      std::vector<int> arr(100'000);
      # then fill with random value in [0, 256]

      for (auto i = 0u; i < 100'000; ++i) {
        if (arr[i] >= 128)
          sum += arr[i];
      }
    code2: |
      std::vector<int> arr(100'000);
      # then fill with random value in [0, 256]

      std::sort(arr, arr + arr.size());

      for (auto i = 0u; i < 100'000; ++i) {
        if (arr[i] >= 128)
          sum += arr[i];
      }
    answer: 2
    faster_factor: 2.4
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/sorted_array.cpp
    explain: |
      With sorted array, the condition `arr[i] >= 128` become easy to predicted (always false at the beginning, and then
      become always true). Without sorted array, that is harder to predict.

      CPU can run multiple instructions at the same time, but branch prevents it from happenning. Therefore, CPU try to
      predict result of the branch and execute instructions based on that prediction to keep the utilization high.

      References:

        - [Wiki](https://en.wikipedia.org/wiki/Branch_predictor)
        - [Why is processing a sorted array faster than processing an unsorted array?](https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array)
  - title: Modulo
    topic: CPU
    code1: |
      std::array<int, 5> modulos{11, 107, 1013, 19211, 81727};

      for (auto i = 0u; i < arr.size(); ++i) {
        sum += arr[i] % modulos[i * 5 / arr.size()];
      }
    code2: |
      for (auto i = 0u; i < arr.size(); ++i) {
        switch (i * 5 / arr.size()) {
          case 0:
            sum += arr[i] % 11;
            break;
          case 1:
            sum += arr[i] % 107;
            break;
          case 2:
            sum += arr[i] % 1013;
            break;
          case 3:
            sum += arr[i] % 19211;
            break;
          case 4:
            sum += arr[i] % 81727;
            break;
        }
      }
    answer: 2
    faster_factor: 1.3
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/modulo.cpp
    explain: |
      Integer modulo (and division) operation in CPU is slow. But there is a trick to convert
      [division by a constant into multiplication](https://en.wikipedia.org/wiki/Division_algorithm#Division_by_a_constant).

      Beware of the branching penalty though. The above example works because the branch is easily predicted.

      In case where you don't know the divisor in compile time, but you know same value is gonna be used multiple times,
      you can use something like [libdivide](https://libdivide.com/)

      References:
      
      - [Division Algorithm - Wiki](https://en.wikipedia.org/wiki/Division_algorithm)
  - title: Power Of Two
    topic: CPU
    code1: |
      int foo(int x) {
        return x % 3; 
      }
    code2: |
      int foo(int x) {
        return x % 128; 
      }
    answer: 2
    faster_factor: 1.2
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/power_of_two.cpp
    explain: |
      Arithmetic operation with power of two can usually be converted into bit shift, or mask
      operation, which is quite cheap

      - x * 2^n == x << n
      - x % 2^n == x & (1 << n - 1)

  - title: Dependency
    topic: CPU
    code1: |
      for (auto i = 0u; i < 90; ++i) {
        sum *= 10;
        sum += a[i];
      }
    code2: |
      for (auto i = 0u; i < 90; i += 3) {
        sum *= 1000;
        sum += a[i] * 100;
        sum += a[i + 1] * 10;
        sum += a[i + 2];
      }
    answer: 2
    faster_factor: 1.3
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/dependency.cpp
    explain: |
      The first code has to be run sequentially pretty much, since the add operation
      must be done after * 10 operation. While in the 2nd code, there are 3 add
      operation that can be done in any order, thus enable more parallelism in CPU.

      References:

      - [Superscalar Processor - Wiki](https://en.wikipedia.org/wiki/Superscalar_processor)
  - title: False Dependency
    topic: CPU
    code1: |
      #include
    code2: |
      #include
    answer: 2
    faster_factor: 2
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/sorted_array.cpp
    explain: |
      TODO
  - title: No Branch
    topic: CPU
    code1: |
      #include
    code2: |
      #include
    answer: 2
    faster_factor: 2
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/sorted_array.cpp
    explain: |
      TODO
  - title: Register Spill
    topic: CPU
    code1: |
      // arr.size == 1'000'000
      constexpr int N = 4;

      for (auto i = 0u; i < arr.size(); i += N) {
        for (int j = 0; j < N; ++j) {
          sum += arr[i + j] * (i + j);
        }
      }
    code2: |
      // arr.size == 1'000'000
      constexpr int N = 8;

      for (auto i = 0u; i < arr.size(); i += N) {
        for (int j = 0; j < N; ++j) {
          sum += arr[i + j] * (i + j);
        }
      }
    answer: 1
    faster_factor: 3.7
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/register.cpp
    explain: |
      TODO
  - title: PTWRITE
    topic: CPU
    code1: |
      #include
    code2: |
      #include
    answer: 2
    faster_factor: 2
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/sorted_array.cpp
    explain: |
      TODO
  - title: Pointer Chasing
    topic: CPU
    code1: |
      #include
    code2: |
      #include
    answer: 2
    faster_factor: 2
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/sorted_array.cpp
    explain: |
      TODO
  - title: Store-To-Loading Forwarding
    topic: CPU
    code1: |
      #include
    code2: |
      #include
    answer: 2
    faster_factor: 2
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/sorted_array.cpp
    explain: |
      TODO
  - title: Async
    topic: CPU
    code1: |
      #include
    code2: |
      #include
    answer: 2
    faster_factor: 2
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/sorted_array.cpp
    explain: |
      TODO



  - title: Inline vs Function Call
    topic: C++
    code1: |
      __attribute__(always_inline) int foo(int x, int y) {
        return x + y;
      }
    code2: |
      __attribute__(noinline) int foo(int x, int y) {
        return x + y;
      }
    answer: 1
    faster_factor: "?"
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpp/function_call.cpp
    explain: |
      Inline function is always faster.

      TODO

  - title: Function Call vs Virtual Function Call
    topic: C++
    code1: |
      #include
    code2: |
      #include
    answer: 2
    faster_factor: "?"
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpp/function_call.cpp
    explain: |
      TODO

  - title: Different Type of Static Variable
    topic: C++
    code1: |
      struct Foo {
        int Add(int x) {
          static Bar a;
          return a += x;
        }
      };
    code2: |
      struct Foo {
        static inline int a{0};

        int Add(int x) {
          return a += x;
        }
      };
    answer: 2
    faster_factor: "?"
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/static_variable.cpp
    explain: |
      TODO

  - title: Signed vs Unsigned
    topic: C++
    code1: |
      struct Foo {
    code2: |
      struct Foo {
    answer: 2
    faster_factor: "?"
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/static_variable.cpp
    explain: |
      TODO

  - title: Shared Pointer
    topic: C++
    code1: |
      struct Foo {
    code2: |
      struct Foo {
    answer: 2
    faster_factor: "?"
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/static_variable.cpp
    explain: |
      TODO

  - title: Smol
    topic: C++
    code1: |
      struct Foo {
    code2: |
      struct Foo {
    answer: 2
    faster_factor: "?"
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/static_variable.cpp
    explain: |
      TODO

  - title: Chaining Function
    topic: C++
    code1: |
      struct Foo {
    code2: |
      struct Foo {
    answer: 2
    faster_factor: "?"
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/static_variable.cpp
    explain: |
      TODO

  - title: ABI
    topic: C++
    code1: |
      struct Foo {
    code2: |
      struct Foo {
    answer: 2
    faster_factor: "?"
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/static_variable.cpp
    explain: |
      TODO

  - title: Batch Processing
    topic: C++
    code1: |
      struct Foo {
    code2: |
      struct Foo {
    answer: 2
    faster_factor: "?"
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/static_variable.cpp
    explain: |
      TODO

  - title: Math Functions
    topic: C++
    code1: |
      struct Foo {
    code2: |
      struct Foo {
    answer: 2
    faster_factor: "?"
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/static_variable.cpp
    explain: |
      TODO

  - title: Loop Reordering
    topic: C++
    code1: |
      struct Foo {
    code2: |
      struct Foo {
    answer: 2
    faster_factor: "?"
    machine: Apple Macbook Air M2
    code_url: https://github.com/hgminh95/fast/blob/main/bench/cpu/static_variable.cpp
    explain: |
      TODO

  - title: Simd1
    topic: SIMD
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      TODO

  - title: Moving Data
    topic: GPU
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      TODO
  - title: Coalesced Access
    topic: GPU
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      TODO
  - title: Misaligned Access
    topic: GPU
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      TODO
  - title: The Swizzle Operator
    topic: GPU
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      TODO
  - title: Kernel Fusion
    topic: GPU
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      TODO
  - title: Kernel Fission
    topic: GPU
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      TODO

  - title: Pipelining
    topic: RTL
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      TODO
  - title: Removing Pipeline Register
    topic: RTL
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      TODO
  - title: Register Layers
    topic: RTL
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      TODO
  - title: Register Balancing
    topic: RTL
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      TODO
  - title: Control-based Logic Reuse
    topic: RTL
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      TODO
  - title: Priority Encoders
    topic: RTL
    code1: |
      #include cpp
      int main() {
      }
    code2: |
      #include cpp
      int main() {
      }
    answer: 1
    faster_factor: 2
    explain: |
      TODO
